alias physicalSP S0;
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);

alias sysCallNo S1;
sysCallNo = [physicalSP - 1];

//print("a");

alias PID S14;
if (PTBR < 1024 + 256) then
	PID = (PTBR - 1024)/8;
else
	PID = 32 + (PTBR - 61*512)/8;
endif;

alias PCB S12;
if (PID < 32) then
	PCB = READY_LIST + PID*32;
else
	PCB = 62*512 + (PID-32)*32;
endif;

//print("b");

alias startPTEntry S15;
alias PTEntryCounter S10;
alias swapPageIndex S13;

if (sysCallNo == 8) then			//Code for Fork()
	
	//print("c");
	
	if (PID >= 48) then
		print("Swap Full");
		ireturn;
	endif;

	alias newPID S2;
	newPID = PID + 1;
	alias newPCB S13;
	if (newPID < 32) then
		newPCB = READY_LIST + newPID*32;
	endif;
	if (newPID >= 32 && newPID < 64) then
		newPCB = 62*512 + (newPID-32)*32;
	endif;
	if (newPID >= 64) then
		newPCB = READY_LIST;
		newPID = 0;
	endif;

	//print("d");

	while ((newPID % 64) != PID) do
		if ([newPCB + 1] == 0) then
			break;
		endif;
		newPID = newPID + 1;	
		if (newPID < 32) then
			newPCB = READY_LIST + newPID*32;
			continue;
		endif;
		if (newPID >= 64) then
			newPCB = READY_LIST;
			newPID = 0;
		else
			newPCB = 62*512 + (newPID-32)*32;
		endif;
	endwhile;

	//print("e");
	
	newPID = newPID % 64;
	
	if (newPID == PID) then
		print("No free PCB");
		[physicalSP - 2] = -1;
		ireturn;
	endif;
	
	alias childPTBR S7;
	if (newPID < 32) then
		childPTBR = 1024 + newPID * 8;
	endif;
	if (newPID >= 32 && newPID < 64) then
		print("NewPId");
		print(newPID);
		childPTBR = 61*512 + (newPID-32) * 8;
		print(childPTBR);
	endif;

	alias i S4;
	i = 25;
	
	//print("f");

	alias freePageIndex S3;

	while (i < 64) do 			// Check for one free page
		if ([MEM_LIST + i] == 0) then
			freePageIndex = i;
			[MEM_LIST + i] = 1;
			break;
		endif;
		i = i + 1;
	endwhile;
	
	//print("g");

	if (i == 64) then				// no memory entry free; so try swapping one out

		startPTEntry = childPTBR - 1024 + 6; 	// Starts at stack
		
		while (1 == 1) do
			
			PTEntryCounter = (startPTEntry + 2) % 256;
			
			while (PTEntryCounter != startPTEntry) do
				
				
				// PTEntryCounter now points to the page number entry
				
				if ([PAGE_TABLE + PTEntryCounter + 1] == "01") then	// check if the memory page is shared or not
					
					if ([MEM_LIST + [PAGE_TABLE + PTEntryCounter]] > 1) then			// page is shared						
						PTEntryCounter = PTEntryCounter + 2;
						continue;
					endif;
					
					// we have an actual victim page
					
					// scan the memory copy of the disk free list for a free block
					// in the swap area
					
					swapPageIndex = 448;
					while (swapPageIndex < 512) do
						if ([DISK_LIST + swapPageIndex] == 0) then
							store([PAGE_TABLE + PTEntryCounter], swapPageIndex);
							// mark swap disk block as used
							[DISK_LIST + swapPageIndex] = 1;
							// store the index of the obtained page 
							freePageIndex = [PAGE_TABLE + PTEntryCounter];
							// mark PTBR entry to point to swap block
							[PAGE_TABLE + PTEntryCounter] = swapPageIndex;
							// set auxiliary information of page as invalid
							[PAGE_TABLE + PTEntryCounter + 1] = "00";
							break;						
						endif;
						swapPageIndex = swapPageIndex + 1;
					endwhile;
						
					if (swapPageIndex == 512) then		// no place to swap the page to
							[physicalSP - 2] = -1;
						ireturn;
					endif;
					
					if (swapPageIndex != 512) then			// we have a valid page index stored in freePageIndex
						break;
					endif;					
						
				endif;
				
				if ([PAGE_TABLE + PTEntryCounter + 1] == "11") then 		// i.e. give second chance
					[PAGE_TABLE + PTEntryCounter + 1] = "01";					
				endif;
				
				PTEntryCounter = (PTEntryCounter + 2) % 256;		
				
			endwhile;
			
			if (PTEntryCounter != startPTEntry) then 		// we have a valid page index stored in freePageIndex
				break;
			endif;
			
		endwhile;
		
	endif;

	//print("h");


	alias wordIndex S6;	// to copy from one page to another
	wordIndex = 0;
	while (wordIndex < 512) do 		// copy the stack
		[freePageIndex * 512 + wordIndex] = [[PTBR + 6] * 512 + wordIndex];
		wordIndex = wordIndex + 1;
	endwhile;
	
	// set fourth entry of child's PTBR as stack
	[childPTBR + 6] = freePageIndex;
	[childPTBR + 7] = "01";	
	
	// update other entries of child's PTBR
	
	i = 0;
	
	while (i < 3) do 				// copy the entries in the page table of parent's process to that of child's process
		
		[childPTBR + i * 2] = [PTBR + i * 2];
		[childPTBR + i * 2 + 1] = [PTBR + i * 2 + 1];
		
		// update memory free list to indicate sharing
		
		if ([PTBR + i * 2 + 1] == "01" || [PTBR + i * 2 + 1] == "11") then
			[MEM_LIST + [PTBR + i * 2]] = [MEM_LIST + [PTBR + i * 2]] + 1;
		endif;
		
		if ([PTBR + i * 2 + 1] == "00" && [PTBR + i * 2] > 447) then 	// indicates that code page resides in the disk in the swap area
			// at this block number
			[DISK_LIST + [PTBR + i * 2]] = [DISK_LIST + [PTBR + i * 2]] + 1; 	// this is used to indicate that the swap block is now shared by more than one process
			store(6, 20);
		endif;
		
		i = i + 1;
		
	endwhile;

		// PPOFT
	alias childPCB S10;
	if (newPID < 32) then
		childPCB = READY_LIST + newPID*32;
	else
		childPCB = 62*512 + (newPID-32)*32;
	endif;

	i = 0;
	while (i < 8) do
		[childPCB + 15 + i * 2] = [PCB + 15 + i * 2];	// pointer to SWOFT
		[childPCB + 15 + i * 2 + 1] = [PCB + 15 + i * 2 + 1];	// LSEEK position
		// increment the file open count in SWOFT
		// [PCB + 15 + i * 2] is SWOFT Index
		if ([childPCB + 15 + i * 2] != -1) then
			// entry is valid
			[FILE_TABLE + [childPCB + 15 + i * 2] * 2 + 1] = [FILE_TABLE + [childPCB + 15 + i * 2] * 2 + 1] + 1;
		endif;
		i = i + 1;
	endwhile;
	
	breakpoint;

	inline "JMP 10752";
	
endif;
